// Copyright Â© 2022 Giorgio Audrito and Lorenzo Testa. All Rights Reserved.

/**
 * @file warehouse.hpp
 * @brief Case study on smart warehouse management.
 *
 * This header file is designed to work under multiple execution paradigms.
 */

#ifndef FCPP_WAREHOUSE_H_
#define FCPP_WAREHOUSE_H_

#include "lib/fcpp.hpp"

#define NO_GOODS 255
#define UNDEFINED_GOODS 254

#define LOG_TYPE_PALLET_CONTENT_CHANGE 1
#define LOG_TYPE_HANDLE_PALLET 2
#define LOG_TYPE_COLLISION_RISK_START 3
#define LOG_TYPE_COLLISION_RISK_END 4

#if FCPP_ENVIRONMENT == FCPP_ENVIRONMENT_PHYSICAL
    #define MSG_SIZE_HARDWARE_LIMIT 224
#else
    #define MSG_SIZE_HARDWARE_LIMIT 224 + 22 // extra space needed for simulation
#endif

// [INTRODUCTION]

//! @brief Enumeration of device types.
enum class warehouse_device_type { Pallet, Wearable };

//! @brief Printing the device types.
std::string to_string(warehouse_device_type t) {
    switch (t) {
        case warehouse_device_type::Pallet:
            return "Pallet";
            break;
        case warehouse_device_type::Wearable:
            return "Wearable";
    }
}

/**
 * @brief Namespace containing all the objects in the FCPP library.
 */
namespace fcpp {
//! @brief Tags used in the node storage and tagged tuples.
namespace coordination {
    namespace tags {
        //! @brief Goods in a pallet or query.
        struct goods_type {};
        //! @brief Type of a log.
        struct log_content_type {};
        //! @brief UID of the logging device.
        struct logger_id {};
        //! @brief Time of the log.
        struct log_time {};
        //! @brief Content of the log.
        struct log_content {};

        //! @brief Whether the device is a Wearable or a Pallet.
        struct node_type {};
        //! @brief Whether a pallet is currently being handled by a wearable.
        struct pallet_handled {};
        //! @brief A query for a good, if any.
        struct querying {};
        //! @brief The goods currently contained in a pallet.
        struct loaded_goods {};
        //! @brief The goods that a wearable is trying to load on a pallet.
        struct loading_goods{};
        //! @brief The logs newly generated by the device.
        struct new_logs {};
        //! @brief The logs being collected by the device.
        struct coll_logs {};
        //! @brief Whether the led is currently on.
        struct led_on {};
        //! @brief Message size of the last message sent.
        struct msg_size {};
        //! @brief Whether the last message was sent.
        struct msg_received__perc {};
        //! @brief The number of log entries just created.
        struct log_created {};
        //! @brief The number of log entries just collected.
        struct log_collected {};
        //! @brief The delays of received logs.
        struct logging_delay {};
    }
}


//! @brief Dummy ordering between positions (allows positions to be used as secondary keys in ordered tuples).
template <size_t n>
bool operator<(vec<n> const&, vec<n> const&) {
    return false;
}

//! @brief Type for the content description of pallets.
using pallet_content_type = common::tagged_tuple_t<coordination::tags::goods_type, uint8_t>;

//! @brief Type for logs.
using log_type = common::tagged_tuple_t<coordination::tags::log_content_type, uint8_t, coordination::tags::logger_id, device_t, coordination::tags::log_time, uint8_t, coordination::tags::log_content, uint16_t>;

//! @brief Type for queries.
using query_type = common::tagged_tuple_t<coordination::tags::goods_type, uint8_t>;

//! @brief Converts a floating-point time to a byte value (tenth of secs precision).
uint8_t discretizer(times_t t) {
    return int(10*t) % 256;
}

}

namespace std {

//! @brief Sorted vector merging.
std::vector<fcpp::log_type> operator+(std::vector<fcpp::log_type> const& x, std::vector<fcpp::log_type> const& y) {
    if (y.size() == 0) return x;
    if (x.size() == 0) return y;
    std::vector<fcpp::log_type> z;
    size_t i = 0, j = 0;
    while (i < x.size() and j < y.size()) {
        if (x[i] <= y[j]) {
            if (x[i] == y[j]) ++j;
            z.push_back(x[i++]);
        } else z.push_back(y[j++]);
    }
    while (i < x.size()) z.push_back(x[i++]);
    while (j < y.size()) z.push_back(y[j++]);
    return z;
}

//! @brief Sorted vector subtraction.
std::vector<fcpp::log_type> operator-(std::vector<fcpp::log_type> x, std::vector<fcpp::log_type> const& y) {
    if (y.size() == 0) return x;
    size_t i = 0;
    for (size_t j=0, k=0; j<x.size(); ++j) {
        while (k < y.size() and y[k] < x[j]) ++k;
        if (k >= y.size() or y[k] > x[j]) x[i++] = x[j];
    }
    x.resize(i);
    return x;
}

//! @brief Tuple hasher.
template <>
struct hash<fcpp::tuple<fcpp::device_t,fcpp::query_type>> {
    size_t operator()(fcpp::tuple<fcpp::device_t,fcpp::query_type> const& k) const {
        return get<fcpp::coordination::tags::goods_type>(get<1>(k)) | (get<0>(k) << 8);
    }
};

}

namespace fcpp {

//! @brief Namespace containing the libraries of coordination routines.
namespace coordination {

// [AGGREGATE PROGRAM]

FUN device_t nearest_pallet_device(ARGS) { CODE
    field<bool> nbr_pallet = nbr(CALL, node.storage(tags::node_type{}) == warehouse_device_type::Pallet);
    return get<1>(min_hood(CALL, make_tuple(mux(nbr_pallet, node.nbr_dist(), INF), node.nbr_uid())));
}
//! @brief Export list for nearest_pallet_device.
FUN_EXPORT nearest_pallet_device_t = common::export_list<bool>;


//! @brief Computes the distance of every neighbour from a source, and the best waypoint towards it (distorting the nbr_dist metric).
FUN tuple<field<real_t>, device_t> distance_waypoint(ARGS, bool source, real_t distortion) { CODE
    return nbr(CALL, INF, [&] (field<real_t> d) {
        real_t dist;
        device_t waypoint;
        tie(dist, waypoint) = min_hood(CALL, make_tuple(d + node.nbr_dist(), node.nbr_uid()), make_tuple(source ? -distortion : INF, node.uid));
        dist += distortion;
        mod_self(CALL, d) = dist;
        return make_tuple(make_tuple(d, waypoint), dist);
    });
}
//! @brief Export list for distance_waypoint.
FUN_EXPORT distance_waypoint_t = common::export_list<real_t>;


//! @brief Null content.
constexpr pallet_content_type null_content{UNDEFINED_GOODS};

//! @brief No content.
constexpr pallet_content_type no_content{NO_GOODS};

//! @brief Extract content for logging.
inline uint16_t log_content(pallet_content_type const& c) {
    return get<tags::goods_type>(c);
}

//! @brief Loads a content.
inline void load_content(pallet_content_type& c, pallet_content_type const& l) {
    c = l;
}

//! @brief Turns loading_goods on wearables into loaded_goods for the closest pallet.
FUN std::vector<log_type> load_goods_on_pallet(ARGS, times_t current_clock) { CODE
    // currently loaded good (pallet) and good to be loaded (wearable)
    pallet_content_type& loading = node.storage(tags::loading_goods{});
    pallet_content_type& loaded  = node.storage(tags::loaded_goods{});
    // whether I am a wearable that is about to load
    bool is_loading = loading != null_content;
    // the loading or loaded good of a neighbor
    field<pallet_content_type> nbr_good = nbr(CALL, is_loading ? loading : loaded);
    // the nearest pallet device for loading neighbors
    device_t nearest = nearest_pallet_device(CALL);
    field<device_t> nbr_nearest = nbr(CALL, is_loading ? constant(CALL, nearest) : node.uid);
    // the loading logs vector
    std::vector<log_type> loading_logs;
    // a loading wearable with a matching nearest good is reset
    if (is_loading and details::self(nbr_good, nearest) == loading) {
        loading = null_content;
        loading_logs.emplace_back(LOG_TYPE_HANDLE_PALLET, node.uid, discretizer(current_clock), nearest);
    }
    // loading good if nearest for a neighbor (breaking ties by highest good type)
    auto t = max_hood(CALL, fcpp::make_tuple(nbr_nearest == node.uid, nbr_good), fcpp::make_tuple(false, no_content));
    if (get<0>(t) and loaded != get<1>(t)) {
        load_content(loaded, get<1>(t));
        loading_logs.emplace_back(LOG_TYPE_PALLET_CONTENT_CHANGE, node.uid, discretizer(current_clock), log_content(get<1>(t)));
    }
    // return loading logs
    return loading_logs;
}
//! @brief Export list for load_goods_on_pallet.
FUN_EXPORT load_goods_on_pallet_t = common::export_list<nearest_pallet_device_t, constant_t<device_t>, pallet_content_type, device_t>;


//! @brief Detects potential collision risks.
FUN std::vector<log_type> collision_detection(ARGS, real_t radius, real_t threshold, times_t current_clock, real_t comm) { CODE
    bool wearable = node.storage(tags::node_type{}) == warehouse_device_type::Wearable;
    std::unordered_map<device_t, real_t> logmap = spawn(CALL, [&](device_t source){
        auto t = distance_waypoint(CALL, node.uid == source, 0.1*comm);
        real_t dist = self(CALL, get<0>(t));
        real_t closest_wearable = nbr(CALL, INF, [&](field<real_t> x){
            return min_hood(CALL, mux(get<0>(t) > dist, x, INF), wearable and node.uid != source ? dist : INF);
        });
        real_t v = 0;
        if (isfinite(closest_wearable))
            v = (old(CALL, closest_wearable) - closest_wearable) / (node.current_time() - node.previous_time());
        return make_tuple(dist < radius ? v : -INF, dist < radius);
    }, wearable ? common::option<device_t>{node.uid} : common::option<device_t>{});
    std::vector<log_type> logvec;
    real_t vn = max(logmap[node.uid], real_t(0));
    real_t vo = old(CALL, vn);
    if (vn > threshold and vo <= threshold)
        logvec.emplace_back(LOG_TYPE_COLLISION_RISK_START, node.uid, discretizer(current_clock), vn);
    if (vo > threshold and vn <= threshold)
        logvec.emplace_back(LOG_TYPE_COLLISION_RISK_END, node.uid, discretizer(current_clock), vn);
    return logvec;
}
//! @brief Export list for collision_detection.
FUN_EXPORT collision_detection_t = common::export_list<spawn_t<device_t, bool>, distance_waypoint_t, real_t>;


//! @brief Searches the direction towards the closest space.
FUN device_t find_space(ARGS, real_t grid_step, real_t comm) { CODE
    bool is_pallet = node.storage(tags::node_type{}) == warehouse_device_type::Pallet and
        node.storage(tags::loaded_goods{}) != no_content and
        node.storage(tags::pallet_handled{}) == false;
    int pallet_count = sum_hood(CALL, field<int>{node.nbr_dist() < 1.2 * grid_step and nbr(CALL, is_pallet)}, 0);
    bool source = is_pallet and pallet_count < 2;
    auto t = distance_waypoint(CALL, source, 0.1*comm);
    real_t dist = self(CALL, get<0>(t));
    return get<1>(t);
}
//! @brief Export list for find_space.
FUN_EXPORT find_space_t = common::export_list<distance_waypoint_t, bool>;

//! @brief No query.
constexpr query_type no_query{NO_GOODS};

//! @brief Whether a pallet content matches a query.
inline bool match(query_type const& q, pallet_content_type const& c) {
    return get<tags::goods_type>(q) == get<tags::goods_type>(c);
}

// TODO: broadcast dist to cut propagation radius?
//! @brief Searches the direction towards the closest pallet with a good matching the query.
FUN device_t find_goods(ARGS, query_type query, real_t comm) { CODE
    using key_type = tuple<device_t,query_type>;
    std::unordered_map<key_type, device_t> resmap = spawn(CALL, [&](key_type const& key){
        bool found = match(get<1>(key), node.storage(tags::loaded_goods{})) && node.storage(tags::pallet_handled{}) == false;
        auto t = distance_waypoint(CALL, found, 0.1*comm);
        real_t dist = self(CALL, get<0>(t));
        device_t waypoint = get<1>(t);
        return make_tuple(waypoint, get<0>(key) != node.uid ? status::internal : query == no_query ? status::terminated : status::internal_output);
    }, query == no_query ? common::option<key_type>{} : common::option<key_type>{node.uid,query});
    return resmap.empty() ? node.uid : resmap.begin()->second;
}
//! @brief Export list for find_goods.
FUN_EXPORT find_goods_t = common::export_list<spawn_t<tuple<device_t,query_type>, status>, distance_waypoint_t>;


//! @brief Checks whether a vector of logs is sorted.
bool is_sorted(std::vector<log_type> const& v) {
    for (size_t i=1; i<v.size(); ++i)
        if (v[i] <= v[i-1]) return false;
    return true;
}

//! @brief Collects logs towards wearables of given UID parity.
FUN std::vector<log_type> single_log_collection(ARGS, std::vector<log_type> const& new_logs, int parity) { CODE
    bool source = node.uid % 2 == parity and node.storage(tags::node_type{}) == warehouse_device_type::Wearable;
    field<hops_t> nbrdist = nbr(CALL, std::numeric_limits<hops_t>::max(), [&](field<hops_t> d){
        hops_t nd = min_hood(CALL, d, source ? hops_t(-1) : std::numeric_limits<hops_t>::max()-1) + 1;
        mod_self(CALL, d) = nd;
        return make_tuple(std::move(d), nd);
    });
    hops_t dist = self(CALL, nbrdist);
    std::vector<log_type> r = nbr(CALL, std::vector<log_type>{}, [&](field<std::vector<log_type>> nl){
        std::vector<log_type> uplogs   = sum_hood(CALL, mux(nbrdist > dist, nl, std::vector<log_type>{}));
        std::vector<log_type> downlogs = sum_hood(CALL, mux(nbrdist < dist, nl, std::vector<log_type>{}));
        return (uplogs - downlogs) + new_logs;
    });
    assert(is_sorted(r));
    return source ? r : std::vector<log_type>{};
}
//! @brief Export list for single_log_collection.
FUN_EXPORT single_log_collection_t = common::export_list<hops_t, std::vector<log_type>>;

//! @brief Collects logs towards wearables with redundancy.
FUN std::vector<log_type> log_collection(ARGS, std::vector<log_type> const& new_logs) { CODE
    assert(is_sorted(new_logs));
    std::vector<log_type> r0 = single_log_collection(CALL, new_logs, 0);
    std::vector<log_type> r1 = single_log_collection(CALL, new_logs, 1);
    return r0.empty() ? r1 : r0;
}
//! @brief Export list for log_collection.
FUN_EXPORT log_collection_t = common::export_list<single_log_collection_t>;


//! @brief Computes some statistics for network analysis.
FUN void statistics(ARGS, times_t current_clock) { CODE
    // message size stats
    node.storage(tags::msg_size{}) = node.msg_size();
    node.storage(tags::msg_received__perc{}) = node.msg_size() <= MSG_SIZE_HARDWARE_LIMIT;
    // log size and delay stats
    node.storage(tags::log_created{}) = node.storage(tags::new_logs{}).size();
    node.storage(tags::log_collected{}) = node.storage(tags::coll_logs{}).size();
    std::vector<times_t> delays;
    for (auto const& log : node.storage(tags::coll_logs{})) {
        uint8_t d = discretizer(current_clock) - get<tags::log_time>(log);
        delays.push_back(d * 0.1);
    }
    node.storage(tags::logging_delay{}) = delays;
}
//! @brief Export list for statistics.
FUN_EXPORT statistics_t = common::export_list<>;


//! @brief Application for warehouse assistance.
FUN device_t warehouse_app(ARGS, real_t grid_step, real_t comm_rad, real_t safety_radius, real_t safe_speed) { CODE
    bool is_pallet = node.storage(tags::node_type{}) == warehouse_device_type::Pallet;
    times_t current_clock = shared_clock(CALL);
    std::vector<log_type>& logs = node.storage(tags::new_logs{});
    logs = {};
    logs = logs + load_goods_on_pallet(CALL, current_clock);
    logs = logs + collision_detection(CALL, safety_radius, safe_speed, current_clock, comm_rad);
    node.storage(tags::coll_logs{}) = log_collection(CALL, logs);
    device_t space_waypoint = find_space(CALL, grid_step, comm_rad);
    device_t goods_waypoint = find_goods(CALL, node.storage(tags::querying{}), comm_rad);
    device_t waypoint = is_pallet ? node.uid : node.storage(tags::querying{}) == no_query ? space_waypoint : goods_waypoint;
    node.storage(tags::led_on{}) = any_hood(CALL, nbr(CALL, waypoint) == node.uid, false);
    statistics(CALL, current_clock);
    return waypoint;
}
//! @brief Export list for warehouse_app.
FUN_EXPORT warehouse_app_t = common::export_list<shared_clock_t, load_goods_on_pallet_t, collision_detection_t, find_space_t, find_goods_t, device_t, log_collection_t, statistics_t>;


} // namespace coordination

} // namespace fcpp


#endif // FCPP_WAREHOUSE_H_
