// Copyright Â© 2022 Giorgio Audrito and Lorenzo Testa. All Rights Reserved.

/**
 * @file warehouse.hpp
 * @brief Case study on smart warehouse management.
 *
 * This header file is designed to work under multiple execution paradigms.
 */

#ifndef FCPP_WAREHOUSE_H_
#define FCPP_WAREHOUSE_H_

#include "lib/fcpp.hpp"

#define NO_GOODS 255
#define UNLOAD_GOODS 254
#define UNDEFINED_GOODS 253

#define LOG_TYPE_PALLET_CONTENT_CHANGE 1
#define LOG_TYPE_HANDLE_PALLET 2
#define LOG_TYPE_COLLISION_RISK 3

#define MSG_SIZE_HARDWARE_LIMIT 224


// [INTRODUCTION]

//! @brief Enumeration of device types.
enum class warehouse_device_type { Pallet, Wearable };

//! @brief Printing the device types.
std::string to_string(warehouse_device_type t) {
    switch (t) {
        case warehouse_device_type::Pallet:
            return "Pallet";
            break;
        case warehouse_device_type::Wearable:
            return "Wearable";
    }
}

/**
 * @brief Namespace containing all the objects in the FCPP library.
 */
namespace fcpp {
//! @brief Tags used in the node storage and tagged tuples.
namespace coordination {
    namespace tags {
        //! @brief Goods in a pallet or query.
        struct goods_type {};
        //! @brief Type of a log.
        struct log_content_type {};
        //! @brief UID of the logging device.
        struct logger_id {};
        //! @brief Time of the log.
        struct log_time {};
        //! @brief Content of the log.
        struct log_content {};

        //! @brief Whether the device is a Wearable or a Pallet.
        struct node_type {};
        //! @brief Whether a pallet is currently being handled by a wearable.
        struct pallet_handled {};
        //! @brief A query for a good, if any.
        struct querying {};
        //! @brief The goods currently contained in a pallet.
        struct loaded_goods {};
        //! @brief The goods that a wearable is trying to load on a pallet.
        struct loading_goods{};
        //! @brief The logs newly generated by the device.
        struct new_logs {};
        //! @brief The logs being collected by the device.
        struct coll_logs {};
        //! @brief Whether the led is currently on.
        struct led_on {};
        //! @brief DEPRECATED [to be moved in simulation]
        struct side_color {};
        //! @brief Message size of the last message sent.
        struct msg_size {};
        //! @brief Whether the last message was sent.
        struct msg_received__perc {};
        //! @brief The number of log entries just created.
        struct log_created {};
        //! @brief The number of log entries just collected.
        struct log_collected {};
        //! @brief The delays of received logs.
        struct logging_delay {};
    }
}


//! @brief Dummy ordering between positions (allows positions to be used as secondary keys in ordered tuples).
template <size_t n>
bool operator<(vec<n> const&, vec<n> const&) {
    return false;
}

//! @brief Type for the content description of pallets.
using pallet_content_type = common::tagged_tuple_t<coordination::tags::goods_type, uint8_t>;

//! @brief Type for logs.
using log_type = common::tagged_tuple_t<coordination::tags::log_content_type, uint8_t, coordination::tags::logger_id, device_t, coordination::tags::log_time, uint8_t, coordination::tags::log_content, uint16_t>;

//! @brief Type for queries.
using query_type = common::tagged_tuple_t<coordination::tags::goods_type, uint8_t>;

//! @brief Converts a floating-point time to a byte value (tenth of secs precision).
uint8_t discretizer(times_t t) {
    return int(10*t) % 256;
}

}

namespace std {

//! @brief Sorted vector merging.
std::vector<fcpp::log_type> operator+(std::vector<fcpp::log_type> const& x, std::vector<fcpp::log_type> const& y) {
    if (y.size() == 0) return x;
    if (x.size() == 0) return y;
    std::vector<fcpp::log_type> z;
    size_t i = 0, j = 0;
    while (i < x.size() and j < y.size()) {
        if (x[i] <= y[j]) {
            if (x[i] == y[j]) ++j;
            z.push_back(x[i++]);
        } else z.push_back(y[j++]);
    }
    while (i < x.size()) z.push_back(x[i++]);
    while (j < y.size()) z.push_back(y[j++]);
    return z;
}

//! @brief Sorted vector subtraction.
std::vector<fcpp::log_type> operator-(std::vector<fcpp::log_type> x, std::vector<fcpp::log_type> const& y) {
    if (y.size() == 0) return x;
    size_t i = 0;
    for (size_t j=0, k=0; j<x.size(); ++j) {
        while (k < y.size() and y[k] < x[j]) ++k;
        if (k >= y.size() or y[k] > x[j]) x[i++] = x[j];
    }
    x.resize(i);
    return x;
}

//! @brief Tuple hasher.
template <>
struct hash<fcpp::tuple<fcpp::device_t,fcpp::query_type>> {
    size_t operator()(fcpp::tuple<fcpp::device_t,fcpp::query_type> const& k) const {
        return get<fcpp::coordination::tags::goods_type>(get<1>(k)) | (get<0>(k) << 8);
    }
};

}

namespace fcpp {

//! @brief Namespace containing the libraries of coordination routines.
namespace coordination {

// [AGGREGATE PROGRAM]

// TODO: use nbr_pallet argument instead (in common with find_space and other)
FUN device_t nearest_pallet_device(ARGS) { CODE
    field<bool> nbr_pallet = nbr(CALL, node.storage(tags::node_type{}) == warehouse_device_type::Pallet);
    return get<1>(min_hood(CALL, make_tuple(mux(nbr_pallet, node.nbr_dist(), INF), node.nbr_uid())));
}
FUN_EXPORT nearest_pallet_device_t = common::export_list<bool>;

FUN std::vector<log_type> load_goods_on_pallet(ARGS, times_t current_clock) { CODE
    using state_type = tuple<device_t,pallet_content_type>;
    std::vector<log_type> loading_logs;
    nbr(CALL, state_type(node.uid, node.storage(tags::loaded_goods{})), [&](field<state_type> fs) {
        state_type last_state = self(CALL, fs);
        pallet_content_type pallet_value = fold_hood(CALL, [&](state_type const& s, pallet_content_type acc) {
            if (get<0>(s) == node.uid) {
                return get<1>(s);
            } else {
                return acc;
            }
        }, fs, get<1>(last_state));
        if (node.storage(tags::node_type{}) == warehouse_device_type::Pallet && get<1>(last_state) != pallet_value) {
            loading_logs.emplace_back(LOG_TYPE_PALLET_CONTENT_CHANGE, node.uid, discretizer(current_clock), get<tags::goods_type>(pallet_value));
        }
        pallet_content_type goods_currenting_loading = node.storage(tags::loading_goods{});
        device_t wearable_device_id = get<0>(last_state);
        pallet_content_type wearable_value = get<1>(last_state);
        device_t nearest = nearest_pallet_device(CALL);
        if (get<0>(last_state) == node.uid && get<tags::goods_type>(goods_currenting_loading) != NO_GOODS) {
            wearable_device_id = nearest;
            if (get<tags::goods_type>(goods_currenting_loading) == UNLOAD_GOODS) {
                wearable_value = NO_GOODS;
            } else {
                wearable_value = goods_currenting_loading;
            }
            loading_logs.emplace_back(LOG_TYPE_HANDLE_PALLET, node.uid, discretizer(current_clock), nearest);
        }
        if (any_hood(CALL, map_hood([&](state_type const& x) {
                return get<0>(x) == get<0>(last_state) && get<1>(x) == get<1>(last_state);
            }, fs)) && get<0>(last_state) != node.uid) {
            node.storage(tags::loading_goods{}) = common::make_tagged_tuple<coordination::tags::goods_type>(NO_GOODS);
            wearable_device_id = node.uid;
            wearable_value = common::make_tagged_tuple<coordination::tags::goods_type>(NO_GOODS);
        }
        if (node.storage(tags::node_type{}) == warehouse_device_type::Pallet) {
            node.storage(tags::loaded_goods{}) = pallet_value;
        }
        return mux(
            node.storage(tags::node_type{}) == warehouse_device_type::Pallet,
            state_type(node.uid, pallet_value),
            state_type(wearable_device_id, wearable_value)
        );
    });
    return loading_logs;
}
FUN_EXPORT load_goods_on_pallet_t = common::export_list<tuple<device_t,pallet_content_type>, nearest_pallet_device_t>;

// TODO: [LATER] tweak distortion
//! @brief Computes the distance of every neighbour from a source, and the best waypoint towards it (distorting the nbr_dist metric).
FUN tuple<field<real_t>, device_t> distance_waypoint(ARGS, bool source, real_t distortion) { CODE
    return nbr(CALL, INF, [&] (field<real_t> d) {
        real_t dist;
        device_t waypoint;
        tie(dist, waypoint) = min_hood(CALL, make_tuple(d + node.nbr_dist(), node.nbr_uid()), make_tuple(source ? -distortion : INF, node.uid));
        dist += distortion;
        mod_self(CALL, d) = dist;
        return make_tuple(make_tuple(d, waypoint), dist);
    });
}
FUN_EXPORT distance_waypoint_t = common::export_list<real_t>;


//! @brief Null content.
constexpr pallet_content_type null_content{UNDEFINED_GOODS};
//! @brief No content.
constexpr pallet_content_type no_content{NO_GOODS};
//! @brief Extract content for logging.
inline uint16_t log_content(pallet_content_type const& c) {
    return get<tags::goods_type>(c);
}
//! @brief Loads a content.
inline void load_content(pallet_content_type& c, pallet_content_type const& l) {
    c = l;
}

////! @brief Turns loading_goods on wearables into loaded_goods for the closest pallet.
//FUN std::vector<log_type> load_goods_on_pallet(ARGS, times_t current_clock) { CODE
//    // currently loaded good (pallet) and good to be loaded (wearable)
//    pallet_content_type& loading = node.storage(tags::loading_goods{});
//    pallet_content_type& loaded  = node.storage(tags::loaded_goods{});
//    // whether I am a wearable that is about to load
//    bool is_loading = loading != null_content;
//    // the loading or loaded good of a neighbor
//    field<pallet_content_type> nbr_good = nbr(CALL, is_loading ? loading : loaded);
//    // the nearest pallet device for loading neighbors
//    device_t nearest = nearest_pallet_device(CALL);
//    field<device_t> nbr_nearest = nbr(CALL, is_loading ? constant(CALL, nearest) : node.uid);
//    // the loading logs vector
//    std::vector<log_type> loading_logs;
//    // a loading wearable with a matching nearest good is reset
//    if (is_loading and details::self(nbr_good, nearest) == loading) {
//        loading = null_content;
//        loading_logs.emplace_back(LOG_TYPE_HANDLE_PALLET, node.uid, discretizer(current_clock), nearest);
//    }
//    // loading good if nearest for a neighbor (breaking ties by highest good type)
//    auto t = max_hood(CALL, fcpp::make_tuple(nbr_nearest == node.uid, nbr_good), fcpp::make_tuple(false, no_content));
//    if (get<0>(t)) {
//        load_content(loaded, get<1>(t));
//        loading_logs.emplace_back(LOG_TYPE_PALLET_CONTENT_CHANGE, node.uid, discretizer(current_clock), log_content(get<1>(t)));
//    }
//    // return loading logs
//    return loading_logs;
//}
////! @brief Export list for load_goods_on_pallet.
//FUN_EXPORT load_goods_on_pallet_t = common::export_list<nearest_pallet_device_t, constant_t<device_t>, pallet_content_type, device_t>;


// TODO: [LATER] tweak threshold
// TODO: [MAYBE] log only risk start and end
FUN std::vector<log_type> collision_detection(ARGS, real_t radius, real_t threshold, times_t current_clock, real_t comm) { CODE
    bool wearable = node.storage(tags::node_type{}) == warehouse_device_type::Wearable;
    std::unordered_map<device_t, real_t> logmap = spawn(CALL, [&](device_t source){
        auto t = distance_waypoint(CALL, node.uid == source, 0.1*comm);
        real_t dist = self(CALL, get<0>(t));
        real_t closest_wearable = nbr(CALL, INF, [&](field<real_t> x){
            return min_hood(CALL, mux(get<0>(t) > dist, x, INF), dist);
        });
        real_t v = 0;
        if (isfinite(closest_wearable))
            v = (old(CALL, closest_wearable) - closest_wearable) / (node.current_time() - node.previous_time());
        return make_tuple(dist < radius ? v : -INF, dist < radius);
    }, wearable ? common::option<device_t>{node.uid} : common::option<device_t>{});
    node.storage(tags::side_color{}) = color(BLACK);
    for (size_t i=0; i<6; ++i)
        if (logmap.count(i + 500) and logmap.at(i + 500) > -INF) {
            node.storage(tags::side_color{}) = color::hsva(i*360/6,1,1,1);
            break;
        }
    std::vector<log_type> logvec;
    if (logmap[node.uid] > threshold)
        logvec.emplace_back(LOG_TYPE_COLLISION_RISK, node.uid, discretizer(current_clock), logmap[node.uid]);
    return logvec;
}
FUN_EXPORT collision_detection_t = common::export_list<spawn_t<device_t, bool>, distance_waypoint_t, real_t>;


// TODO: [LATER] set led on outside, to save further messages
FUN device_t find_space(ARGS, real_t grid_step, real_t comm) { CODE
    bool is_pallet = node.storage(tags::node_type{}) == warehouse_device_type::Pallet && 
        get<tags::goods_type>(node.storage(tags::loaded_goods{})) != NO_GOODS &&
        node.storage(tags::pallet_handled{}) == false;
    int pallet_count = sum_hood(CALL, field<int>{node.nbr_dist() < 1.2 * grid_step and nbr(CALL, is_pallet)}, 0);
    bool source = is_pallet and pallet_count < 2;
    auto t = distance_waypoint(CALL, source, 0.1*comm);
    real_t dist = self(CALL, get<0>(t));
    device_t waypoint = get<1>(t);
    node.storage(tags::led_on{}) = any_hood(CALL, nbr(CALL, waypoint) == node.uid, false);
    return waypoint;
}
FUN_EXPORT find_space_t = common::export_list<distance_waypoint_t, bool, device_t>;

inline bool match(query_type const& q, pallet_content_type const& c) {
    return get<tags::goods_type>(q) == get<tags::goods_type>(c);
}

inline bool empty(query_type const& q) {
    return get<tags::goods_type>(q) == NO_GOODS;
}

// TODO: [LATER] broadcast dist to cut propagation radius
// TODO: [LATER] set led on outside, to save further messages
// TODO: [MAYBE] bloom filter to guide process expansion
FUN device_t find_goods(ARGS, query_type query, real_t comm) { CODE
    using key_type = tuple<device_t,query_type>;
    std::unordered_map<key_type, device_t> resmap = spawn(CALL, [&](key_type const& key){
        bool found = match(get<1>(key), node.storage(tags::loaded_goods{})) && node.storage(tags::pallet_handled{}) == false;
        auto t = distance_waypoint(CALL, found, 0.1*comm);
        real_t dist = self(CALL, get<0>(t));
        device_t waypoint = get<1>(t);
        return make_tuple(waypoint, get<0>(key) != node.uid ? status::internal : empty(query) ? status::terminated : status::internal_output);
    }, empty(query) ? common::option<key_type>{} : common::option<key_type>{node.uid,query});
    device_t waypoint = resmap.empty() ? node.uid : resmap.begin()->second;
    node.storage(tags::led_on{}) = any_hood(CALL, nbr(CALL, waypoint) == node.uid, false);
    return waypoint;
}
FUN_EXPORT find_goods_t = common::export_list<spawn_t<tuple<device_t,query_type>, status>, distance_waypoint_t, device_t>;


bool is_sorted(std::vector<log_type> const& v) {
    for (size_t i=1; i<v.size(); ++i)
        if (v[i] <= v[i-1]) return false;
    return true;
}

FUN std::vector<log_type> single_log_collection(ARGS, std::vector<log_type> const& new_logs, int parity) { CODE
    bool source = node.uid % 2 == parity and node.storage(tags::node_type{}) == warehouse_device_type::Wearable;
    field<hops_t> nbrdist = nbr(CALL, std::numeric_limits<hops_t>::max(), [&](field<hops_t> d){
        hops_t nd = min_hood(CALL, d, source ? hops_t(-1) : std::numeric_limits<hops_t>::max()-1) + 1;
        mod_self(CALL, d) = nd;
        return make_tuple(std::move(d), nd);
    });
    hops_t dist = self(CALL, nbrdist);
    std::vector<log_type> r = nbr(CALL, std::vector<log_type>{}, [&](field<std::vector<log_type>> nl){
        std::vector<log_type> uplogs   = sum_hood(CALL, mux(nbrdist > dist, nl, std::vector<log_type>{}));
        std::vector<log_type> downlogs = sum_hood(CALL, mux(nbrdist < dist, nl, std::vector<log_type>{}));
        return (uplogs - downlogs) + new_logs;
    });
    assert(is_sorted(r));
    return source ? r : std::vector<log_type>{};
}
FUN_EXPORT single_log_collection_t = common::export_list<hops_t, std::vector<log_type>>;

FUN std::vector<log_type> log_collection(ARGS, std::vector<log_type> new_logs) { CODE
    std::sort(new_logs.begin(), new_logs.end());
    assert(is_sorted(new_logs));
    std::vector<log_type> r0 = single_log_collection(CALL, new_logs, 0);
    std::vector<log_type> r1 = single_log_collection(CALL, new_logs, 1);
    return r0.empty() ? r1 : r0;
}
FUN_EXPORT log_collection_t = common::export_list<single_log_collection_t>;


//! @brief Computes some statistics for network analysis.
FUN void statistics(ARGS, times_t current_clock) { CODE
    node.storage(tags::msg_size{}) = node.msg_size();
    node.storage(tags::msg_received__perc{}) = node.msg_size() <= MSG_SIZE_HARDWARE_LIMIT;
    node.storage(tags::log_created{}) = node.storage(tags::new_logs{}).size();
    node.storage(tags::log_collected{}) = node.storage(tags::coll_logs{}).size();
    std::vector<times_t> delays;
    for (auto const& log : node.storage(tags::coll_logs{})) {
        uint8_t d = discretizer(current_clock) - get<tags::log_time>(log);
        delays.push_back(d * 0.1);
    }
    node.storage(tags::logging_delay{}) = delays;
}
//! @brief Export list for statistics.
FUN_EXPORT statistics_t = common::export_list<>;


//! @brief Application for warehouse assistance.
FUN void warehouse_app(ARGS, real_t grid_step, real_t comm_rad, real_t safety_radius, real_t safe_speed) { CODE
    bool is_pallet = node.storage(tags::node_type{}) == warehouse_device_type::Pallet;
    bool nbr_pallet = nbr(CALL, is_pallet);
    times_t current_clock = shared_clock(CALL);
    std::vector<log_type>& logs = node.storage(tags::new_logs{});
    logs = {};
    logs = logs + load_goods_on_pallet(CALL, current_clock);
    logs = logs + collision_detection(CALL, safety_radius, safe_speed, current_clock, comm_rad);
    node.storage(tags::coll_logs{}) = log_collection(CALL, logs);
    device_t space_waypoint = find_space(CALL, grid_step, comm_rad);
    device_t goods_waypoint = find_goods(CALL, node.storage(tags::querying{}), comm_rad);
    device_t waypoint = is_pallet ? node.uid : goods_waypoint != node.uid ? goods_waypoint : space_waypoint;
    node.storage(tags::led_on{}) = any_hood(CALL, nbr(CALL, waypoint) == node.uid, false);
    statistics(CALL, current_clock);
}
//! @brief Export list for warehouse_app.
FUN_EXPORT warehouse_app_t = common::export_list<bool, shared_clock_t, load_goods_on_pallet_t, collision_detection_t, find_space_t, find_goods_t, device_t, log_collection_t, statistics_t>;


} // namespace coordination

} // namespace fcpp


#endif // FCPP_WAREHOUSE_H_
